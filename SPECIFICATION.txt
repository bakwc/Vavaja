
Регистры общего назначения:

  целые	вещественные
(2 байта)	(4 байта)
ah			eax
bh			ebx
ch			ecx
dh			edx
eh			eex

sp	- указатель на вершину стека целых чисел
esp   -  указатель на вершину стека вещественных чисел
pc	- указатель на текущую команду

Стэк растёт вверх. По умолчанию целый и вещественный стэк
инициализируется адресом, который идёт сразу после кода.

Команды:

mov 1 ah

1 - что кладём
eax - куда кладём
1, 10, 23 - обычные числа
1.0, 5.3, 4.2 - дробные числа
ah, bh, ch - обычные регистры
eax, efx - вещественные регистры
%1, %10, %3 - абсолютные адреса (берем из памяти)
%ah, %bh, %ch - обращение по адресу, записанному в регистре (только для целых регистров)


add 4 eh
аргументы - простые числа, вещественные числа, простые регистры, вещественные регистры
4 - на сколько увеличиваем (числа или регистры из которых брать числа)
eh - что увеличиваем (регистры)

sub 6 dh
аргументы - простые числа, вещественные числа, простые регистры, вещественные регистры
То же самое, только уменьшаем

mul ch
аргумент - простое число, вещественное число, простой регистр, вещественный регистр
умножает регистр ah (или eax) на аргумент (результат в регистр ah ил eax)
аргумент может быть числом или регистром

div fh
аргумент - простое число, вещественное число, простой регистр, вещественный регистр
делит регистр ah (или eax) на аргумент. Остаток от деления в eh
аргумент может быть числом или регистром

label:
метка, может иметь любое имя
чтобы получить адрес метки, пишем label
чтобы получить значение, по адресу метки, пишем %label

jmp %31
jmp %label
переход выполнения на метку
аргумент - адрес (целое число), метка, или регистр в котором лежит адрес

call %31
call %label
размещение на стэке адреса возврата, переход выполнения на метку, 
аргумент - адрес (целое число), метка, или регистр в котором лежит адрес

ret
команда без аргументов
Извлекает из стэка адрес, прыгает по этому адресу

cmp ah 10
сравнение двух аргументов
аргументы - простые числа, вещественные числа, простые регистры, вещественные регистры
если равно, заносит 0 в eh
если первый аргумент больше заносит 1 в eh
если второй аргумент больше заносит -1 в eh

je %label
прыжок если в eh 0 (числа равны)

jg %label
прыжок если в eh 1 (первый аргумент больше)

jl %label
прыжок если в eh -1 (первый аргумент меньше)

push ch
аргумент - простое число, вещественное число, простой регистр, вещественный регистр
положить значение из ch на стэк

pop bh
аргумент - простое число, вещественное число, простой регистр, вещественный регистр
извлечь значение со стэка в bh

pass
пустая команда без аргументов

int 10
прерывания
аргумент - цел_число


Данные

.byte 48	- однин байт
.short 8912	- целое число, два байта
.float 23.5 - дробное число, четыре байта
.string Hello, world! - автоматически вставляется строку
				(конвертирует в ascii, добавляет 0-й символ)
.ascii Hello, world! - тоже самое, только без добавление 0-го символа
.space 10 - пропускает заданное количество байт (ничего не кладёт)


Команды занимают:			1 байт
Номера (названия) регистров:		1 байт
Целые числа занимают:			2 байта
Дробные числа:				4 байта

Список прерываний:

10 - выход из программы
11 - вывод числа из регистра ah на экран
12 - вывод числа из регистра eax на экран
13 - ввод числа в регистр ah (с клавиатуры)
14 - ввод числа в регистр eax (с клавиатуры)
15 - вывод текста на экран, лежащего по адресу из регистра ah до 0-го символа
16 - ввод текста с клавиатуры в память по адресу из ah. В bh будет лежать длина введенного текста
17 - сброс в файл отладочной информации (дамп регистров и памяти)
18 - вывод текста на экран, лежащего по адресу из регистра ah до 0-го символа, с переводом строки


Обозначения регистров:
Регистры обозначаются номером, занимают 1 байт:
0 - ah
1 - bh
2 - ch
3 - dh
4 - eh
5 - sp
6 - pc
7 - rh
0 - eax
1 - ebx
2 - ecx
3 - edx
4 - eex
5 - esp

Байт-коды команд:

OP_MOV_1	1 mov цел_число цел_регистр
OP_MOV_2	2 mov цел_число память
OP_MOV_3	3 mov цел_число память_из_регистра

OP_MOV_4	4 mov дроб_число дроб_регистр
OP_MOV_5	5 mov дроб_число память
OP_MOV_6	6 mov дроб_число память_из_регистра

OP_MOV_7	7 mov цел_регистр цел_регистр
OP_MOV_8	8 mov цел_регистр память
OP_MOV_9	9 mov цел_регистр память_из_регистра

OP_MOV_10	10 mov дроб_регистр дроб_регистр
OP_MOV_11	11 mov дроб_регистр память
OP_MOV_12	12 mov дроб_регистр память_из_регистра

OP_MOV_13	13 mov память цел_регистр
OP_MOV_14	14 mov память дроб_регистр
OP_MOV_15	15 mov память_из_регистра цел_регистр
OP_MOV_16	16 mov память_из_регистра дроб_регистр

OP_MOV_17	17 mov цел_регистр дроб_регистр
OP_MOV_18	18 mov дроб_регистр цел_регистр

OP_PASS		19 pass (пустая команда)

OP_INT		20 int (прерывание, аргумент - цел_число)

OP_ADD_1	22 add цел_число цел_регистр
OP_ADD_2	23 add цел_регистр цел_регистр
OP_ADD_3	24 add дроб_число дроб_регистр
OP_ADD_4	25 add дроб_регистр дроб_регистр

OP_SUB_1	26 sub цел_число цел_регистр
OP_SUB_2	27 sub цел_регистр цел_регистр
OP_SUB_3	28 sub дроб_число дроб_регистр
OP_SUB_4	29 sub дроб_регистр дроб_регистр

OP_MUL_1	30 mul цел_число
OP_MUL_2	31 mul цел_регистр
OP_MUL_3	32 mul дроб_число
OP_MUL_4	33 mul дроб_регистр

OP_DIV_1	34 div цел_число
OP_DIV_2	35 div цел_регистр
OP_DIV_3	36 div дроб_число
OP_DIV_4	37 div дроб_регистр

OP_JMP_1	40 jmp число
OP_JMP_2	41 jmp цел_число
OP_JE_1		42 je число
OP_JE_2		43 je цел_число
OP_JG_1		44 jg число
OP_JG_2		45 jg цел_число
OP_JL_1		46 jl число
OP_JL_2		47 jl цел_число
OP_JNE_1	48 jne число
OP_JNE_2	49 jne цел_число

OP_CMP_1	50 cmp цел_число цел_регистр
OP_CMP_2	51 cmp цел_регистр цел_регистр
OP_CMP_3	52 cmp дроб_число дроб_регистр
OP_CMP_4	53 cmp дроб_регистр дроб_регистр

OP_PUSH_1	60 push цел_число
OP_PUSH_2	61 push цел_регистр
OP_PUSH_3	62 push вещ_число
OP_PUSH_4	63 push вещ_регистр

OP_POP_1	65 pop цел_регистр
OP_POP_2	66 pop вещ_регистр

OP_CALL_1	70 call память
OP_CALL_2	71 call память_из_регистра
OP_RET		75 ret
		
OP_AND_1	76 and цел_число цел_регистр
OP_AND_2	77 and цел_регистр цел_регистр
OP_OR_1		78 or  цел_число цел_регистр
OP_OR_2		79 or  цел_регистр цел_регистр
OP_XOR_1	80 xor цел_число цел_регистр
OP_XOR_2	81 xor цел_регистр цел_регистр
OP_NOT		82 not цел_регистр
